<% extends base.html %>

<% title %>
Debugging
<%/ title %>

<% body %>
    <div id='header'>
      <div id='logo'>
        <h1>Debugging</h1>
      </div>
    </div>

    <h2 id='contents'>Table of contents</h2>
    <ul>
      <li><a href='#intro'>Introduction</a></li>
      <ul>
        <li><a href='#traceback'>Traceback Messages</a></li>
        <li><a href='#error-message'>Error Messages</a></li>
      </ul>
      <li><a href='#debugging'>Debugging Process</a></li>
      <ul>
        <li><a href='#doctests'>Running Doctests</a></li>
        <li><a href='#write-tests'>Writing your own tests</a></li>
        <li><a href='#print'>Using print Statements</a></li>
        <li><a href='#debug'>Long-term debugging</a></li>
      </ul>
      <li><a href='#error-types'>Error Types</a></li>
      <li><a href='#bugs'>Common Bugs</a></li>
    </ul>

    <h2 id='intro'>Introduction</h2>

    <p>By now, you will have encountered various bugs when programming
    for this class. Most often, you will try to run your code and see
    something like this:</p>

    <pre class='prettyprint'>
Traceback (most recent call last):
  File "&lt;pyshell#29&gt;", line 3, in &lt;module&gt;
    result = buggy(5)
  File "&lt;pyshell#29&gt;", line 5, in buggy
    return f + x
TypeError: unsupported operand type(s) for +: 'function' and 'int'</pre>

    <p>This is called a <i>traceback</i> message. It prints out the
    chain of function calls that led up to the error, with the most
    recent function call at the bottom. You can follow this chain to
    figure out which function(s) caused the problem.</p>

    <h3 id='traceback'>Traceback Messages</h3>

    <p>Notice that the lines in the traceback appear to be paired
    together. The <b>first</b> line in such a pair has the following
    format:</p>

    <pre class='prettyprint'>
File "&lt;file name&gt;", line &lt;number&gt;, in &lt;function&gt;</pre>

    <p>That line provides you with the following information:</p>

    <ul>
      <li><b>File name</b>: the name of the file that contains the
      problem.
      <li><b>Number</b>: the line number in the file that caused the
      problem, or the line number that contains the next function
      call.</li>
      <li><b>Function</b>: the name of the function in which the line
      can be found.</li>
    </ul>

    <p>The <b>second</b> line in the pair (it's indented farther in
    than the first) displays the actual line of code that makes
    the <i>next</i> function call. This gives you a quick look at what
    arguments were passed into the function, in what context the
    function was being used, etc.</p>

    <p>Finally, remember that the traceback is organized with the
    "most recent call last."</p>

    <h3 id='error-message'>Error Messages</h3>

    <p>The very last line in the traceback message is the error
    statement. An <i>error statement</i> has the following format:</p>

    <pre class='prettyprint'>
&lt;error type&gt;: &lt;error message&gt;</pre>

    <p>This line provides you with two pieces of information:</p>

    <ul>
      <li><b>Error type</b>: the type of error that was caused (e.g.
      <tt>SyntaxError</tt>, <tt>TypeError</tt>). These are usually
      descriptive enough to help you narrow down your search for the
      cause of error.</li>

      <li><b>Error message</b>: a more detailed description of exactly
      what caused the error. Different error types produce different
      error messages.</li>
    </ul>

    <h2 id='debugging'>Debugging Process</h2>

    <h3 id='doctests'>Running doctests</h3>

    <p>Python has a great way to quickly write tests for your code.
    These are called doctests, and look like this:

    <pre class='prettyprint'>
def foo(x):
    """A random function.

    &gt;&gt;&gt; foo(4)
    4
    &gt;&gt;&gt; foo(5)
    5
    """</pre>

    <p>The lines in the docstring that look like interpreter outputs
    are the <b>doctests</b>. To run them, go to your terminal and
    type:</p>

    <pre class='prettyprint'>
python3 -m doctest file.py</pre>

    <p>This effectively loads your file into the Python interpreter,
    and checks to see if each doctest input (e.g. <tt>foo(4)</tt>)
    is the same as the specified output (e.g. <tt>4</tt>). If it
    isn't, a message will tell you which doctests you failed.</p>

    <p>The command line tool has a <tt>-v</tt> option that stands for
    "verbose."</p>

    <pre class='prettyprint'>
python3 -m doctest file.py -v</pre>

    <p>In addition to telling you which doctests you failed,
    it will also tell you which doctests passed. I personally find
    that information unnecessary, so I usually leave <tt>-v</tt> out.

    <p>Usually, we will provide doctests for you in the starter files.
    <b>Always run these doctests</b>. Submitting an assignment without
    running doctests even once is practically throwing points away.</p>

    <p>Also, <b>do not manually type in doctests into the
    interpreter</b>. The whole point of writing doctests is so you
    don't have to do that. Manually typing in doctests requires you to
    (1) open up a Python shell, (2) type in every doctest, (3) manually
    check if the output matches the doctest, (4) repeat. Running
    doctests from the command line requires you to (1) type in a
    single line, and (2) that's it!</p>

    <h3 id='write-tests'>Writing your own tests</h3>

    <p>In addition to doctests, you can write your own tests. There
    are two ways to do this: (1) write additional doctests, or (2)
    write testing functions.</p>

    <p>Writing your own tests is good practice for the future.
    Remember, before the project deadlines, our autograder only runs
    sanity tests -- a subset of all the tests we will eventually run.
    In other words, <b>passing the autograder does not mean you get
    full credit</b>. As such, it is a very good idea to write your own
    test cases.</p>

    <p>To write more doctests, simply follow the style of existing
    doctests. You can also write your own functions (much like the
    <tt>take_turn_test</tt> function from Project 1).</p>

    <p>Some advice in writing tests:</p>
    <ul>
      <li><b>Write some tests before you write code</b>: this is
      called test-driven development. Writing down how you expect the
      function to behave first -- this can guide you when writing the
      actual code.</li>

      <li><b>Write more tests after you write code</b>: once you are
      sure your code passes the initial doctests, write some more
      tests to take care of edge cases.</li>

      <li><b>Test edge cases</b>: make sure your code works for all
      special cases.</li>
    </ul>

    <h3 id='print'>Using <tt>print</tt> statements</h3>

    <p>Once the doctests tell you where the error is, you have to
    figure what went wrong. If the doctest gave you a traceback
    message, look at what <a href='#error-types'>type of error</a> it
    is to help narrow your search. Also check that you aren't making
    any <a href='#bugs'>common mistakes</a>.</p>

    <p>When you first learn how to program, it can be hard to spot
    bugs in your code. One common practice is to add <tt>print</tt>
    statements. For example, let's say the following function
    <tt>foo</tt> keeps returning the wrong thing:

    <pre class='prettyprint'>
def foo(x):
    result = some_function(x)
    return result // 5</pre>

    <p>We can add a print statement before the return to check what
    <tt>some_function</tt> is returning:</p>

    <pre class='prettyprint'>
def foo(x):
    result = some_function(x)
    <b>print('result is', result)</b>
    return other_function(result)</pre>

    <p>If it turns out <tt>result</tt> is not what we expect it to be,
    we would go look in <tt>some_function</tt> to see if it works
    properly. Otherwise, we might have to add a print statement before
    the return to check <tt>other_function</tt>:</p>

    <pre class='prettyprint'>
def foo(x):
    result = some_function(x)
    print('result is', result)
    tmp = other_function(result)
    <b>print('other_function returns', tmp)</b>
    return tmp</pre>

    <p>Some advice:</p>
    <ul>
      <li>Don't just print out a variable -- add some sort of message
      to make it easier for you to read:
    <pre class='prettyprint'>
print(tmp)   # harder to keep track
print('tmp was this:', tmp)  # easier</pre></li>

      <li>Use <tt>print</tt> statements to view the results of
      function calls (i.e. after function calls).</li>

      <li>Use <tt>print</tt> statements at the end of a <tt>while</tt>
      loop to view the state of the counter variables after each
      iteration:
    <pre class='prettyprint'>
i = 0
while i &lt; n:
    i += func(i)
    <b>print('i is', i)</b></pre></li>

      <li>Don't just put <tt>random</tt> print statements after lines
      that are obviously correct.</li>
    </ul>

    <h3 id='debug'>Long-term debugging</h3>

    <p>The <tt>print</tt> statements described above are meant for
    quick debugging of one-time errors -- after figuring out the
    error, you would remove all the <tt>print</tt> statements.</p>

    <p>However, sometimes we would like to leave the debugging code if
    we need to periodically test our file. It can get kind of annoying
    if every time we run our file, debugging messages pop up. One way
    to avoid this is to use a global <tt>debug</tt> variable:</p>

    <pre class='prettyprint'>
debug = True

def foo(n):
    i = 0
    while i &lt; n:
        i += func(i)
        <b>if debug:
            print('i is', i)</b></pre></li>

    <p>Now, whenever we want to do some debugging, we can set the
    global <tt>debug</tt> variable to <tt>True</tt>, and when we don't
    want to see any debugging input, we can turn it to <tt>False</tt>
    (such a variable is called a "flag").</p>

    <h2 id='error-types'>Error Types</h2>
    <p>The following are common error types that Python programmers
    run into.</p>

    <ol>
      <li><tt>SyntaxError</tt>
        <ul>
          <li><b>Cause</b>: code syntax mistake
          <li><b>Example</b>:
          <pre class='prettyprint'>
  File "file name", line number
    def incorrect(f)
                    ^
SyntaxError: invalid syntax</pre>
          <li><b>Solution</b>: the <tt>^</tt> symbol points to the
          code that contains invalid syntax. The error message doesn't
          tell you <i>what</i> is wrong, but it does tell you
          <i>where</i>.</li>
          <li><b>Notes</b>: Python will check for
          <tt>SyntaxErrors</tt> before executing any code. This is
          different from other errors, which are only raiased during
          runtime.</li>
        </ul>
      </li>

      <li><tt>IndentationError</tt>
        <ul>
          <li><b>Cause</b>: improper indentation
          <li><b>Example</b>:
          <pre class='prettyprint'>
  File "file name", line number
    print('improper indentation')
IndentationError: unindent does not match any outer indentation level</pre>
          <li><b>Solution</b>: The line that is improperly indented is
          displayed. Simply re-indent it.</li>
          <li><b>Notes</b>: If you are inconsistent with tabs and
          spaces, Python will raise one of these. Make sure you use
          either spaces or tabs, not both!</li>
        </ul>
      </li>

      <li><tt>TypeError</tt>
        <ul>
          <li><b>Cause 1</b>:
            <ul>
              <li>Invalid operand types for primitive operators. You
              are probably trying to add/subract/multiply/divide
              incompatible types.</li>
              <li><b>Example</b>:
                <pre class='prettyprint'>
TypeError: unsupported operand type(s) for +: 'function' and 'int'</pre></li>
            </ul>
          </li>

          <li><b>Cause 2</b>:
            <ul>
              <li>Using non-function objects in function calls.</li>
              <li><b>Example</b>:
                <pre class='prettyprint'>
&gt;&gt;&gt; square = 3
&gt;&gt;&gt; square(3)
Traceback (most recent call last):
  ...
TypeError: 'int' object is not callable</pre></li>
            </ul>
          </li>

          <li><b>Cause 3</b>:
            <ul>
              <li>Passing an incorrect number of arguments to a
              function.</li>
              <li><b>Example</b>:
                <pre class='prettyprint'>
&gt;&gt;&gt; add(3)
Traceback (most recent call last):
  ...
TypeError: add expected 2 arguments, got 1</pre></li>
            </ul>
          </li>
        </ul>
      </li>

      <li><tt>NameError</tt>
        <ul>
          <li><b>Cause</b>: variable not assigned to anything OR it
          doesn't exist. This includes function names.</li>
          <li><b>Example</b>:
          <pre class='prettyprint'>
  File "file name", line number
    y = x + 3
NameError: global name 'x' is not defined</pre></li>
          <li><b>Solution</b>: Make sure you are initializing the
          variable (i.e. assigning the variable to a value) before you
          use it.</li>
          <li><b>Notes</b>: The reason the error message says "global
          name" is because Python will start searching for the
          variable from a function's local frame. If the variable is
          not found there, Python will keep searching the parent
          frames until it reaches the global frame. If it still can't
          find the variable, Python raises the error.</li>
        </ul>
      </li>

      <li><tt>IndexError</tt>
        <ul>
          <li><b>Cause</b>: trying to index a sequence (e.g. a tuple,
          list, string) with a number that exceeds the size of the
          sequence.</li>
          <li><b>Example</b>:
          <pre class='prettyprint'>
  File "file name", line number
    x[100]
IndexError: tuple index out of range</pre></li>
          <li><b>Solution</b>: Make sure the index is within the
          bounds of the sequence. If you're using a variable as an
          index (e.g. <tt>seq[x]</tt>, make sure the variable is
          assigned to a proper index.</li>
        </ul>
      </li>
    </ol>

    <h2 id='bugs'>Common Bugs</h2>

    <ul>
      <li><b>Spelling and Capitalization</b>: Python is <i>case
      sensitive</i>. The variable <tt>hello</tt> is not the same as
      <tt>Hello</tt> or <tt>hello</tt> or <tt>helo</tt>. This will
      usually show up as a <tt>NameError</tt>, but sometimes
      misspelled variables will actually have been defined. In that
      case, it can be difficult to find errors, and it is never
      gratifying to discover it's just a spelling mistake.</li>

      <li><b>Missing Parentheses</b>: A common bug is to leave off the
      closing parenthesis. This will show up as a
      <tt>SyntaxError</tt>. Consider the following code:
          <pre class='prettyprint'>
def fun():
    return foo(bar()   # missing a parenthesis here

fun()</pre>
      Python will raise a <tt>SyntaxError</tt>, but will point to the
      line <i>after</i> the missing parenthesis:
          <pre class='prettyprint'>
  File "file name", line "number"
    fun()
      ^
SyntaxError: invalid syntax</pre>
      In general, if Python points a <tt>SyntaxError</tt> to a
      seemingly correct line, you are probably forgetting a
      parenthesis somewhere.</li>

      <li><b>Missing close quotes</b>: this is similar to the previous
      bug, but much easier to catch. Python will actually tell you the
      line that is missing the quote:
          <pre class='prettyprint'>
  File "file name", line "number"
    return 'hi
             ^
SyntaxError: EOL while scanning string literal</pre>
      <tt>EOL</tt> stands for "End of Line."</li>

      <li><b><tt>=</tt> vs. <tt>==</tt></b>: the single equal sign
      <tt>=</tt> is used for <i>assignment</i>; the double equal sign
      <tt>==</tt> is used for testing equivalence. The most common
      error of this form is something like:
          <pre class='prettyprint'>
if x = 3:</pre></li>

      <li><b>Infinite Loops</b>: Infinite loops are often caused by
      <tt>while</tt> loops whose conditions never change. For example:
          <pre class='prettyprint'>
i = 0
while i &lt; 10:
    print(i)</pre>
      Sometimes you might have incremented the wrong counter:
          <pre class='prettyprint'>
i, n = 0, 0
while i &lt; 10:
    print(i)
    n += 1</pre></li>

      <li><b>Off-by-one errors</b>: sometimes a <tt>while</tt> loop or
      recursive function might stop one iteration too short. Here,
      it's best to walk through the iteration/recursion to see what
      number the loop stops at.</li>
    </ul>
<%/ body %>

