<!DOCTYPE html>
<html>
  <head>
    <title>Indexing notation</title>
    <link rel='stylesheet' type='text/css' href='../style.css'>
    <link rel='stylesheet' type='text/css' href='../prettify/prettify.css'>
    <script src='../prettify/prettify.js'></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
        Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-39937584-1', 'berkeley.edu');
      ga('send', 'pageview');
    </script>

  </head>
  <body onload="prettyPrint()">
    <div id='header'>
      <div id='logo'>
        <h1>Indexing Notation</h1>
      </div>
    </div>
    <p>Using indexing notation with sequences (such as tuples) is very
    helpful. You can use indexing to retrieve individual items from
    sequences, or you can get a subsequence from a starting index to
    an ending index.</p>

    <h2 id='contenst'>Table of contents</h2>
    <ul>
      <li>1. Index Notation</li>
      <ul>
        <li><a href='#1.1'>1.1 Retrieving individual items</a></li>
        <li><a href='#1.2'>1.2 Retrieving Subsequences</a></li>
        <li><a href='#1.3'>1.3 Slicing other things</a></li>
      </ul>
      <li><a href='#2'>2. Generator expressions</a></li>
      <li>3. <tt>map</tt>, <tt>filter</tt>, and other functions</li>
      <ul>
        <li><a href='#3.1'>3.1 <tt>map</tt></a></li>
        <li><a href='#3.2'>3.2 <tt>filter</tt></a></li>
        <li><a href='#3.3'>3.3 <tt>reduce</tt></a></li>
        <li><a href='#3.4'>3.4 <tt>enumerate</tt></a></li>
        <li><a href='#3.5'>3.5 <tt>zip</tt></a></li>
      </ul>
    </ul>

    <h2 id='1.1'>1.1 Retrieving individual items</h2>
    <p>The notation for <b>individual item retrieval</b> is
    <tt>tup[i]</tt>, where <tt>i</tt> is the value of the index.
    Remember, Python begins indexing at 0, up until
    <tt>len(seq) - 1</tt>.</p>

    <p><i>Note</i>: You MUST use <tt>ints</tt> as indices -- using
    something like <tt>float</tt> will raise a <tt>TypeError</tt>.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tup = (1, 2, 3, 4, 5)
&gt;&gt;&gt; tup[0]   # indices begin at 0
1
&gt;&gt;&gt; tup[4]   # indices end at len(tup) - 1
5
&gt;&gt;&gt; tup[5]   # improperly large indices raise IndexErrors
IndexError
&gt;&gt;&gt; tup[2]
3</pre>

    <p>Positive indexing gives us the <i>(i-1)</i>th element from the
    beginning. What if we want to get the <i>i</i>th element from the
    end? Solution: use <b><i>negative indices</i></b>!</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tup              # using the same tuple as before
(1, 2, 3, 4, 5)
&gt;&gt;&gt; tup[-1]          # get last element
5
&gt;&gt;&gt; tup[-3]          # get the third element from the end
3
&gt;&gt;&gt; tup[-len(tup)]   # improperly large index
IndexError</pre>

    <h2 id='1.2'>1.2 Subsequences</h2>
    <p>You can use <b>slicing notation</b> to retrieve subsequences
    from existing tuples. The resulting subsequence also a tuple.</p>
    <pre class='prettyprint'>
&gt;&gt;&gt; tup              # using the same tuple as before
(1, 2, 3, 4, 5)
&gt;&gt;&gt; tup[1:3]         # subsequence starts at index 1 up to but not including index 3
(2, 3)
&gt;&gt;&gt; tup[0:len(tup)]  # one (not so good) way to get the whole tuple
(1, 2, 3, 4, 5)
&gt;&gt;&gt; tup[-4:]         # start: 4th item from the end, to the very end
(2, 3, 4, 5)</pre>

    <p>Slicing notation has a nice <b>shorthand notations</b>:

    <pre class='prettyprint'>
&gt;&gt;&gt; tup[:3]    # ommiting the left-hand index starts from the very beginning
(1, 2, 3)
&gt;&gt;&gt; tup[3:]    # ommiting the right-hand index goes to the very end
(3, 4, 5)
&gt;&gt;&gt; tup[:]     # dupliates the entire tuple
(1, 2, 3, 4, 5)</pre>

    <p>When slicing, you can use <b>indices that exceed the length of
    the tuple</b> (although that's not good style). Python is smart
    enough to correct the mistake.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tup[2:100]     # 100 &gt; len(tup)
(3, 4, 5)
&gt;&gt;&gt; tup[3:2]       # if left - index &gt; right - index, return empty tuple
()
&gt;&gt;&gt; tup[-100:]     # abs(-100) &gt; len(tup)
(1, 2, 3, 4, 5)</pre>

    <p>You can also specify the <b>increment step-size</b> for
    slicing. The notation is <tt>tup[start:end:step]</tt>

    <pre class='prettyprint'>
&gt;&gt;&gt; tup[1:4:2]   # subsequence from index 1 up to index 4, but only getting every other item
(2, 4)
&gt;&gt;&gt; tup[0:4:3]   # subsequence from index 0 up to index 4, but only getting every third item
(1, 4)
&gt;&gt;&gt; tup[:4:2]    # subsequence from index 0 up to index 4, but only getting every other item
(1, 3)
&gt;&gt;&gt; tup[1::2]    # subsequence from index 1 up to end, but only getting every other item
(2, 4)
&gt;&gt;&gt; tup[::2]     # subsequence from beginning up to end, but only getting every other item
(1, 3, 5)
&gt;&gt;&gt; tup[::-1]    # get the entire tuple but in reverse.
(5, 4, 3, 2, 1)</pre>

    <h2 id='1.3'>1.3 Slicing other things</h2>
    <p>Slicing notation also works on <tt>strings</tt> (and other
    built-in data structures, like <tt>list</tt>s, but you haven't
    learned about those yet).

    <pre class='prettyprint'>
&gt;&gt;&gt; 'This works too!'
&gt;&gt;&gt; s[5]        # get the character at index 5
(5, 4, 3, 2, 1)
&gt;&gt;&gt; s[5:10]     # goes up to but not including index 5
'works'
&gt;&gt;&gt; s[:-1]      # everything up till the last character, '!'
'this works too'</pre>

    <h2 id='2'>2. Generator expressions</h2>
    <p>Python has a short hand for generating large sequences in a
    single line. The syntax for a generator expression is:</p>

    <pre class='prettyprint'>
&lt;expression&gt; for &lt;elem&gt; in &lt;sequence&gt; if &lt;boolean&gt;</pre>

    <p>This will return a "generator object," which you can then
    convert to a tuple.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tuple(i**2 for i in (1, 2, 3, 4, 5) if i % 2 == 0)
(4, 16)
&gt;&gt;&gt; f = lambda x: x / 2
&gt;&gt;&gt; tuple(f(elem) for elem in (1, 2, 3, 4)) # the if is optional
(0.5, 1.0, 1.5, 2.0)</pre>

    <h2>3. <tt>map</tt>, <tt>filter</tt>, and other functions</h2>

    <p>In lecture, you learned about <tt>map</tt>, <tt>filter</tt>,
    and <tt>reduce</tt>. Here are some extra details about them.

    <h2 id='3.1'>3.1 <tt>map</tt></h2>
    <p>In lecture, you saw that <tt>map</tt> can take two arguments: a
    <i>function</i>; and an <i>iterable</i> (e.g. a tuple). The
    function is applied to each item in the iterable. <tt>map</tt>
    returns a "map object," which can be converted to tuples.

    <pre class='prettyprint'>
&gt;&gt;&gt; tuple(map(lambda x: 2*x, (1, 2, 3, 4)))
(2, 4, 6, 8)
&gt;&gt;&gt; tuple(map(lambda x: x**2, (1, 2, 3, 4)))
(1, 4, 9, 16)</pre>

    <p>There is an extended form of <tt>map</tt>, which takes in three
    or more arguments.</p>

    <pre class='prettyprint'>
map(function, iterable1, iterable2, ...)</pre>

    <p><tt>function</tt> will be applied in parallel to all the
    iterables (all the items, then all the second, then all the
    third). The <tt>function</tt> must take as many arguments as there
    are iterables. For example, if there are three iterables,
    <tt>function</tt> must take three arguments.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tuple(map(lambda x, y: x + y, (1, 2, 3, 4), (4, 3, 2, 1)))
(5, 5, 5, 5)    # (1 + 4, 2 + 3, 3 + 2, 4 + 1)
&gt;&gt;&gt; tuple(map(lambda x, y, z: x + y + z, (1, 2), (3, 4), (5, 6)))
(9, 12)</pre>

    <p><i>Note</i>: if the iterables are not of the same length, map
    will only go until the shortest iterable runs out.</p>

    <h2 id='3.2'>3.2 <tt>filter</tt></h2>
    <p><tt>filter</tt> just returns a new sequence, whose items are
    items in the original sequence that passed the <tt>filter</tt>
    function. The format of a filter call is</p>

    <pre class='prettyprint'>
filter(pred, iterable)</pre>

    <p>Here are some examples:</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tuple(filter(lambda x: x % 2, (1, 2, 3, 4, 5)))
(2, 4)                  # keeps even numbers
&gt;&gt;&gt; tuple(filter(lambda s: len(s) &gt; 3, ('hi', 'hello', 'fooply')))
('hello', 'fooply')     # keep words whose lengths exceed 3</pre>

    <h2 id='3.3'>3.3 <tt>reduce</tt></h2>
    <p><tt>reduce</tt> takes a sequence and uses a function to
    "combine" all the items in the sequence. The result is usually an
    int. The format is</p>

    <pre class='prettyprint'>
reduce(function, iterable)</pre>

    <p><tt>function</tt> must take in two arguments. Here are some
    examples.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; reduce(add, (1, 2, 3, 4, 5)) # sums numbers 1 through 5
15
&gt;&gt;&gt; reduce(lambda a, b: a*b, (1, 2, 3)) # multiplies numbers 1 through 3
6</pre>

    <p><tt>reduce</tt> can also take an optional 3rd argument, a
    starting point.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; reduce(add, (1, 2, 3, 4, 5), 10) # sums numbers 1 through 5
25</pre>

    <h2 id='3.4'>3.4 <tt>enumerate</tt></h2>
    <p>The <tt>enumerate</tt> function can be applied in a <tt>for</tt>
    loop to get the index of an item along with the item itself.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; tup = ('a', 'b', 'c')
&gt;&gt;&gt; for i, item in enumerate(tup):
...     print(i, item)
0 a
1 b
2 c</pre>

    <p>This is useful when you want both the index and the item in a
    loop (no need to initialize an index variable before the
    loop).</p>

    <h2 id='3.5'>3.5 <tt>zip</tt></h2>
    <p>The <tt>zip</tt> function takes a number of iterables, and
    pairs together the items in parallel. For example, it pairs
    together the first items, then the second, then the third items.
    <tt>zip</tt> returns a 'zip object', which you can convert into a
    tuple.</p>

    <pre class='prettyprint'>
&gt;&gt;&gt; a = (1, 2, 3, 4)
&gt;&gt;&gt; b = (5, 6, 7, 8):
&gt;&gt;&gt; tuple(zip(a, b))
((1, 5), (2, 6), (3, 7), (4, 8))</pre>

  </body>
</html>



