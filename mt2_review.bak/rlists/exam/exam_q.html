<html>
  <head>
    <title>RLists Exam-style Questions</title>
    <style type="text/css" href="../style.css"></style>
    <style type="text/css">
      ol.BasicsQ2 {
        list-style-type:lower-alpha;
      }
    </style>
  </head>
  <body>
    <h1>RLists Exam-style Questions</h1>
    <h2>Contents</h2>
    <ul class="contents">
      <li class="contents"><a class="ref" href="#print">What would Python print?</a></li>
      <li class="contents"><a class="ref" href="#code">Code-writing</a></li>
    </ul>

    <p>We will be using the following implementation of mutable Rlists.
    <b>NOTE: this implementation may or may NOT be used on the exam. 
    When solving these problems, focus on the <i>process</i> (i.e.
    how to use first and rest) rather than on the answer.</b></p>

    <pre class="codeblock">
    empty = None

    class Rlist:
        def __init__(self, first, rest=empty):
            self.first = first
            self.rest = rest

        def __repr__(self):
            if self.rest == empty:
                return 'Rlist({})'.format(self.first)
            return 'Rlist({}, {})'.format(self.first, repr(self.rest))
    </pre>

    <p>This class, as well as relevant starter code for this document can
    be found <a href="exam.py">here</a>.</p>

    <h2 id="print">What would Python print?</h2>
    <p><b>NOTE:</b> Don't forget the <tt>repr</tt> method defined in
    our implementation! It determines the string representation of 
    printed Rlists.</p>

    <p><b>NOTE:</b> Remember, the implementation on the exam may or
    may not be the same as the one presented here. When solving the
    following problems, you should focus on the <i>process</i> of 
    solving them, not on the actual answers.</p>

    <pre class="codeblock">
    &gt;&gt;&gt; r = Rlist(1, Rlist(2, Rlist(3)))
    &gt;&gt;&gt; a = Rlist(4, Rlist(5))
    &gt;&gt;&gt; r.first = a
    &gt;&gt;&gt; r
    ______
    # is this a valid rlist?
    ______
    &gt;&gt;&gt; r.first.rest
    ______
    &gt;&gt;&gt; r.first.rest = r.rest 
    &gt;&gt;&gt; r
    ______
    &gt;&gt;&gt; a.rest.first == r.rest.first
    ______
    &gt;&gt;&gt; a.rest is r.rest
    ______
    </pre>

    <h2 id="code">Code writing</h2>
    <p>1) Implement a function <tt>alternate</tt> which takes an Rlist,
    and returns a new Rlist that contains <i>every other</i> element in
    the original Rlist.
    <pre class="codeblock">
    def alternate(rlist):
        """Returns a new Rlist that contains every other element of the
        original.

        &gt;&gt;&gt; r = Rlist(1, Rlist(2, Rlist(3)))
        &gt;&gt;&gt; alternate(r)
        Rlist(1, Rlist(3))
        &gt;&gt;&gt; r = Rlist(1, Rlist(2, Rlist(3, Rlist(4))))
        &gt;&gt;&gt; alternate(r)
        Rlist(1, Rlist(3))
        """
        "*** YOUR CODE HERE ***" 
      
    </pre>

    <p>2) Implement a function <tt>reverse</tt> that takes an 
    Rlist as an argument, and returns a new Rlist that contains all the
    elements of the original Rlist, but in reverse order. If an element
    of the rlist is itself an rlist, the elements of that nested rlist
    will remain in order.</p>
    <pre class="codeblock">
    def reverse(rlist):
        """Returns a list with the same elements as the Rlist in 
        reverse order.

        &gt;&gt;&gt; rlist = Rlist(1, Rlist(2, Rlist(3)))
        &gt;&gt;&gt; reverse(rlist)
        Rlist(3, Rlist(2, Rlist(1)))
        &gt;&gt;&gt; rlist = Rlist(Rlist(1, Rlist(2)), Rlist(3))
        &gt;&gt;&gt; reverse(rlist)
        Rlist(3, Rlist(Rlist(1, Rlist(2))))
        """
        "*** YOUR CODE HERE ***"
    </pre>

    <p>3) Implement a function <tt>deep_map</tt> which applies a
    function <tt>f</tt> onto each element of an Rlist. If an element is
    itself an Rlist, recursively apply <tt>deep_map</tt> onto that
    element. Do NOT return anything -- you should instead mutate the 
    original Rlist.</p>
    <pre class="codeblock">
    def deep_map(rlist, f):
        """Apply f onto each element in rlist -- if an element is an 
        rlist, apply f onto each of its elements as well.

        &gt;&gt;&gt; r = Rlist(1, Rlist(Rlist(2, Rlist(3)), Rlist(4)))
        &gt;&gt;&gt; deep_map(r, lambda x: x**2)
        &gt;&gt;&gt; r
        Rlist(1, Rlist(Rlist(4, Rlist(9)), Rlist(16)))
        """
        "*** YOUR CODE HERE ***"
    </pre>

    <p>4) Implement a function <tt>deep_max</tt> which find the largest
    element in an Rlist. If any of its elements are themselves Rlists,
    deep_max should be applied recursively to them</p>
    <pre class="codeblock">
    def deep_max(rlist):
        """Find the largest element in an Rlist and any of its nested
        Rlists.

        &gt;&gt;&gt; r = Rlist(1, Rlist(Rlist(4, Rlist(3)), Rlist(2)))
        &gt;&gt;&gt; deep_max(r)
        4
        """
        "*** YOUR CODE HERE ***"
    </pre>
  </body>
</html>
