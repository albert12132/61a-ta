<html>
  <head>
    <title>Interpreters: basic - solutions</title>
    <link rel="stylesheet" type="text/css" href="../../style.css">
    <link rel="stylesheet" type="text/css" href="../../template/style.css">
  </head>
  <body>
    <div id='header'>
      <div id='logo'>
        <h1 id="title">Interpreters: Basic Solutions</h1>
      </div>
    </div>

    <div id='contents'>
      <h2>Contents</h2>
      <ol>
        <li><a href="#conceptual">Conceptual</a></li>
      </ol>
    </div>

    <h2 class="subtopic" id="conceptual">Conceptual</h2>

    <h3 class="question">Q1</h3>
    <p class="solution"><b>Answer</b>: REPL stands for 
    Read-Eval-Print-Loop. The first step, Read, involves the tokenizer 
    and the parser -- they convert user input (a string) and convert it
    into data structures that are understood by the evaluator. The 
    Evaluator converts those data structures into values, which are 
    then Printed out to the screen. The loop then restarts the whole 
    process.</p>

    <h3 class="question">Q2</h3>
    <p class="solution"><b>Answer</b>: the tokenizer takes user input
    (a string) and breaks it up into tokens. This is an intermediate
    step in the parser.</p>

    <h3 class="question">Q3</h3>
    <p class="solution"><b>Answer</b>: The parser converts a string
    of user input into an expression. The parser is not responsible for
    evaluating the expression -- as such, the parser checks if
    expressions are well-formed, but not if they actually evaluate to
    intelligible values (e.g., in Scheme, <tt>(3 + 2)</tt> is 
    well-formed, but doesn't evaluate to a proper value)</p>

    <p class="solution">The evaluator takes expression objects given
    by the parser and evaluates it.</p>

    <h3 class="question">Q4</h3>
    <p class="solution"><b>Answer</b>:</p>
    <ol>
      <li><tt>do_lambda_form</tt>: <b class='prompt'>Evaluator</b></li>
      <li><tt>tokenize</tt>: <b class='prompt'>Parser</b></li>
      <li><tt>Buffer</tt>: <b class='prompt'>Parser</b></li>
      <li><tt>Frame</tt>: <b class='prompt'>Evaluator</b></li>
      <li><tt>read_tail</tt>: <b class='prompt'>Parser</b></li>
      <li><tt>make_call_frame</tt>: <b class='prompt'>Evaluator</b></li>
      <li><tt>scheme_eval</tt>: <b class='prompt'>Evaluator</b></li>
      <li><tt>scheme_read</tt>: <b class='prompt'>Parser</b></li>
      <li><tt>LambdaProcedure</tt>: <b class='prompt'>Evaluator</b></li>
    </ol>

    <h3 class="question">Q5</h3>
    <p class="solution"><b>Answer</b>: <tt>scheme_eval</tt> will call
    <tt>scheme_apply</tt> when it is evaluating function calls.
    <tt>scheme_apply</tt> will then create a new environment, and 
    call <tt>scheme_eval</tt> on the body of the function. Notice that
    this procedure is different than the one for the Calculator
    language, because Calculator was simple enough not require
    mutual recursion.</p>

  </body>
</html>
